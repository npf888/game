package com.tools.finder;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import com.tools.finder.IFucker.ExploitFucker;

/**
 * 军功作弊者查询器
 * <p>
 * 判断规则: 根据QA-->LIUAO 描述的条件生成;
 * 
 * @author Thinker
 * 
 */
public class ExploitFuckerFinder extends BaseFuckerFinder<ExploitFucker> 
{
	/** 查询军功日志信息SQL */
	private String queryExploitLogSql;

	public ExploitFuckerFinder(String logTableName)
	{
		super(logTableName);
		try 
		{
			// 构建sql
			queryExploitLogSql = "select * from " + logTableName
					+ " where char_name = ? and createTime < " + TIME2
					+ " and createTime > " + TIME1
					+ " order by createTime desc limit 0, "
					+ FuckerConstants.LIMIT_COUNT;

		} catch (Exception e) 
		{
			throw new RuntimeException("Get connection error", e);
		}
	}

	/**
	 * 判断一个角色是否是投机分子
	 * <P>
	 * 1.首先从数据库中取出此用户的前50条指定时间的记录降序; 2.然后从第一条起选出5分钟之内有3次param中含有FUCK_POSTFIX的玩家
	 * 3.如果玩家满足2,则返回此玩家;否则返回NullFucker
	 * 
	 * @param charName
	 * @return
	 */
	@Override
	public ExploitFucker areYouFucker(String charName, long uuid)
	{
		List<ExploitRecord> exploitRecords = getRecords(charName);
		if (exploitRecords.size() > 0) 
		{
			logger.info("Character: " + charName+"'s exploit record count is: "+exploitRecords.size());
		}
		int exploitCount = calculateExpolitFuckTime(exploitRecords);
		if (exploitCount < FuckerConstants.JUDGE_COUNT)
		{
			return null;
		}
		return new ExploitFucker(charName, uuid, exploitCount);
	}

	/**
	 * 是否是投机分子
	 * 
	 * @param records
	 * @return
	 */
	private int calculateExpolitFuckTime(List<ExploitRecord> records) 
	{
		if (records.size() < FuckerConstants.JUDGE_COUNT)
		{
			return records.size();
		}
		int result = 0;
		for (ExploitRecord record : records)
		{
			if (record.getParam().endsWith(FuckerConstants.FUCK_POSTFIX)) 
			{
				result++;
			} else 
			{
				continue;
			}
		}
		return result;
	}

	/**
	 * 判断时间是否合适
	 * 
	 * @param record
	 * @param minTime
	 * @param maxTime
	 * @return
	 */
	protected boolean isTimeSuit(ExploitRecord record, long minTime,long maxTime)
	{
		if (record.getTime() <= maxTime && record.getTime() >= minTime)
		{
			return true;
		}
		return false;
	}

	/**
	 * 从数据库中取出指定的记录
	 * 
	 * @param charName
	 * @param dateTime
	 * @return
	 */
	@SuppressWarnings("unchecked")
	@Override
	public List<ExploitRecord> getRecords(String charName)
	{
		List<ExploitRecord> records = new ArrayList<ExploitRecord>();
		ResultSet rs = null;
		try
		{
			PreparedStatement ps = logConnection.prepareStatement(queryExploitLogSql);
			ps.setString(1, charName);
			rs = JDBCUtil.query(ps, queryExploitLogSql);
			while (rs.next())
			{
				ExploitRecord record = new ExploitRecord();
				record.setCharName(charName);
				record.setTime(rs.getLong("createTime"));
				record.setParam(rs.getString("param"));
				records.add(record);
			}
		} catch (SQLException e)
		{
			logger.error("GerRecords failed, charName: " + charName, e);
		}
		return records;
	}

	/**
	 * 这里的排序较为特殊, 跟基类有些不同
	 */
	@Override
	protected void doFuckerSort(List<ExploitFucker> fuckers)
	{
		Collections.sort(fuckers, new Comparator<ExploitFucker>() 
		{
			@Override
			public int compare(ExploitFucker fucker1, ExploitFucker fucker2)
			{
				if (fucker1.getFuckCount() > fucker2.getFuckCount())
				{
					return -1;
				} else if (fucker1.getFuckCount() < fucker2.getFuckCount()) 
				{
					return 1;
				}
				return 0;
			}

		});
	}
}
